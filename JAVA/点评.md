## Redis
### redis指令
进入redis安装目录：cd /usr/local/src/redis-7.2.6
**以 `redis` 用户运行 Redis**（推荐）：sudo -u redis redis-server redis.conf
编辑 `redis.conf`：sudo nano redis.conf

看redis在后台有没有运行：ps -ef | grep redis

Redis 服务是以 `redis` 用户身份运行的（PID 为 941），而你尝试用普通用户 (`a`) 执行 `kill -9 941` 时被系统拒绝（**不允许的操作**）。这是因为：
> **Linux 权限规则**：普通用户只能终止自己启动的进程，无法终止其他用户的进程（如 `redis` 用户运行的进程）。

 使用 `sudo` 强制终止：sudo kill -9 941

```
redis-cli
127.0.0.1:6379> AUTH yourpassword  # 手动输入密码
OK
127.0.0.1:6379> PING
PONG
```

### 常见命令:
1. 键操作
	查看所有键：keys *
	删除键：del mykey
	设置键过期时间：expire mykey 60
	检查键是否存在：exists mykey

2. 字符串操作
	设置键值set mykey "Hello, Redis!"
	获取键值get mykey
	增加数值incr mycounter
	批量设置多个键值mset key1 "value1" key2 "value2"
	● SET:添加或者修改已经存在的一个String类型的键值对
	● GET:根据key获取String类型的value
	● MSET:批量添加多个String类型的键值对
	● MGET:根据多个key获取多个String类型的value
	● INCR:让一个整型的key自增1
	● INCRBY:让一个整型的key自增并指定步长,例如:incrby num 2让num值自增2
	● INCRBYFLOAT:让一个浮点类型的数字自增并指定步长
	● SETNX:添加一个String类型的键值对,前提是这个key不存在,否则不执行
	● SETEX:添加一个String类型的键值对,并且指定有效期

3. 列表操作
	从左侧插入元素lpush mylist "item1"
	获取列表长度llen mylist
	获取整个队列的元素lrange mylist 0 -1
	从右侧弹出元素并返回rpop mylist
	使用loop模拟阻塞队列1. bloop user 100，（超时时间）如果队列为空则等待100s）。2. lpush 键入值，bloop获取产生输出，停止搜索

4. 集合操作
	添加元素到集合sadd myset "member1"
	获取集合中的所有成员smembers myset
	 检查成员是否存在于集合中sismember myset "member1"
	获取两个集合的交集sinter set1 set2
	● SADD key member ...: 向set中添加一个或多个元素
	● SREM key member ...: 移除set中的指定元素
	● SCARD key:返回set中元素的个数
	● SISMEMBER key member:判断一个元素是否存在于set中
	● SMEMBERS:获取set中的所有元素
	● SINTER key1 key2 ..: 求key1与key2的交集
	● SDIFF key1 key2 ..: 求key1与key2的差集
	● SUNION key1 key2 ..: 求key1和key2的并集

5. 哈希操作
	设置哈希字段值hset myhash field1 "value1"
	获取哈希字段值hget myhash field1
	获取所有字段和值hgetall myhash
	 删除哈希字段hdel myhash field1
	 批量添加多个hash类型key的field值HMSET，获取HMGET
	 获取一个hash类型的key中所有的field：HKEYS
	 获取一个hash类型的key中所有的value：HVALS
	 key字段自增并指定步长：HINCRBY

6. 有序集合操作sortedset
	添加成员及其分数到有序集合zadd myzset 1 "member1"
	获取指定范围内的成员（按分数排序）zrange myzset 0 -1 withscores
	删除成员zrem myzset "member1"
	● ZADD key score member:添加一个或多个元素到sorted set,如果已经存在则更新其score值
	● ZREM key member:删除sorted set中的一个指定元素
	● ZSCORE key member:获取sorted set中的指定元素的score值
	● ZRANK key member:获取sorted set中的指定元素的排名
	● ZCARD key:获取sorted set中的元素个数
	● ZCOUNT key min max:统计score值在给定范围内的所有元素的个数
	● ZINCRBY key increment member:让sorted set中的指定元素自增,步长为指定的increment值
	● ZRANGE key min max:按照score排序后,获取指定排名范围内的元素
	● ZRANGEBYSCORE key min max:按照score排序后,获取指定score范围内的元素
	● ZDIFF、ZINTER、ZUNION:求差集、交集、并集
	
|特性|栈(Stack)实现|队列(Queue)实现|
|---|---|---|
|入操作命令|`LPUSH`|`RPUSH`|
|出操作命令|`LPOP`|`LPOP`|
|顺序|后进先出(LIFO)|先进先出(FIFO)|
|典型应用|撤销操作、函数调用栈|任务队列、消息处理|

redis可能出现的问题：big key问题，分页，排序，oom

## 短信登录验证
1. 登录有效期问题，
	1. 需求：用户操作时一直保持登录状态。
	2. 问题：用户使用时也会在ttl时间之后断开登录。
	3. 解决
		拦截器1：RefreshTokenInterceptor拦截所有，（包括未登录时可以使用的页面和操作）。获取请求头中的token，没有则放行，进入第二个拦截器。查询用户不存在（即token无效）也放行。
		拦截器2：拦截登录状态，
2. 手机格式错误之后，验证码发送按钮依旧设置60s后重发，没有进行重置
	1. 需求：报出手机格式错误之后，可以缓冲几秒之后，验证码按钮进行重置

## 商户查询缓存
### 业务逻辑
1. 查询是否存在于redis缓存中stringRedisTemplate   get
2. 存在(redis缓存命中），转成java对象(JSONUtil.toBean，JSONUtil.toList)返回
3. 命中空缓存（防穿透），返回null
4. redis缓存未命中，进入缓存重建流程（防止缓冲击穿，使用互斥锁）
	1. 获取互斥锁
	2. 获取失败，休眠之后递归重试
	3. 获取成功
		1. 根据 查询条件 查询数据库
			1. 不存在或为空，缓存空值（防穿透），返回错误信息
			2. 存在，转为json格式存到redis缓存中set，设置过期时间，并返回结果
	4. 释放锁
5. 逻辑过期处理
	1. 缓存未命中直接返回空
	2. 缓冲命中，获取过期时间，解析data和expireTime
	3. 判断逻辑是否过期
		1. 未过期，返回商铺信息
		2. 过期，尝试获取互斥锁
			1. 获取成功，缓存重建，立即返回旧数据
				1. 查询商铺数据
				2. 封装逻辑过期时间
				3. 写入redis
				4. 释放锁
			2. 获取失败，返回旧的商铺信息
	```java
		public Shop queryWithLogicalExpire(Long id) {
	    String key = CACHE_SHOP_KEY + id;
	    // 1. 从 Redis 查询缓存
	    String json = stringRedisTemplate.opsForValue().get(key);
	    if (StrUtil.isBlank(json)) {
	        return null; // 缓存不存在，走正常查询流程（如查库+写入）
	    }
	    
	    // 2. 解析缓存数据
	    RedisData<Shop> redisData = JSONUtil.toBean(json, new TypeReference<RedisData<Shop>>() {}, false);
	    Shop shop = redisData.getData();
	    Long expireTime = redisData.getExpireTime();
	    
	    // 3. 判断是否逻辑过期
	    if (expireTime > System.currentTimeMillis()) {
	        // 未过期，直接返回
	        return shop;
	    }
	    
	    // 4. 已过期，尝试获取锁
	    String lockKey = LOCK_SHOP_KEY + id;
	    boolean isLock = tryLock(lockKey);
	    if (isLock) {
	        // 5. 获取锁成功，异步重建
	        CompletableFuture.runAsync(() -> {
	            try {
	                rebuildCache(id); // 重建缓存（查库+写入）
	            } finally {
	                unlock(lockKey);
	            }
	        }, executor); // 使用自定义线程池
	    }
	    // 6. 返回旧数据（无论是否重建）
	    return shop;
	}
	
	// 重建缓存方法
	public void rebuildCache(Long id) {
	    // 1. 查数据库
	    Shop shop = getById(id);
	    // 2. 设置新过期时间（如30分钟后）
	    RedisData<Shop> redisData = new RedisData<>(shop, System.currentTimeMillis() + 30 * 60 * 1000);
	
	    // 3. 写入Redis
	    stringRedisTemplate.opsForValue().set(
	        CACHE_SHOP_KEY + id,
	        JSONUtil.toJsonStr(redisData)
	    );
	}
	```
6. 封装缓存工具类
	1. 泛型处理`<R> R`
	2. 数据库查询问题：由调用函数的人告诉应该怎么查，因为有参有返回值，利用Function指定参数和返回值类型
7. 存在的问题
	1. **递归重试**可能导致栈溢出：高并发下线程可能多次递归，最终抛出 StackOverflowError
		1. 改为循环重试
	2. 锁竞争性能瓶颈：所有线程竞争同一键的锁，高并发时延迟高。
	3. 未处理缓存重建失败：若数据库查询或缓存写入失败，会返回 `null` 且无重试机制
	4. 锁释放可能失败：unlock(lockKey) 若抛出异常，锁会泄漏。可以添加异常捕获
8. 优化
	1. 保证缓存一致性：双删策略（数据库更新后删除缓存，延迟进行第二次删除（异步执行try catch）
		双删的 **第一次删除** 必须与数据库操作在 **同一事务** 中（确保原子性）。
		第二次删除是 **最终一致性** 的补偿措施。
		延迟时间（如500ms）需根据业务并发量调整：高并发场景：500ms~1s，低并发场景：200ms~500ms
		```java
		public void updateShopType(ShopType type) {
		    // 1. 先更新数据库
		    updateById(type);
		    
		    // 2. 删除缓存
		    stringRedisTemplate.delete(CACHE_SHOP_TYPE_LIST_KEY);
		    
		    // 3. 延迟再删一次（防止并发导致脏数据）
		    new Thread(() -> {
		        try {
		            Thread.sleep(500);
		            stringRedisTemplate.delete(CACHE_SHOP_TYPE_LIST_KEY);
		        } catch (InterruptedException e) {
		            Thread.currentThread().interrupt();
		        }
		    }).start();
		}
		```
	2. 大数据量：分页缓存（.page(new Page<>(page, size))）/使用增量更新策略
	3. 空值处理：如果数据库查询为空，也应缓存空结果（防止缓存穿透）
	4. **设置过期时间**：防止脏数据长期存在（30分钟）
		```java
			stringRedisTemplate.opsForValue().set(
	        CACHE_SHOP_TYPE_LIST_KEY,
	        JSONUtil.toJsonStr(typeList),
	        30, 
	        TimeUnit.MINUTES
		    );
		```
	5. 
### 缓存
1. 作用：降低后端负载；提高读写效率，降低响应时间
2. 成本：数据一致性成本，代码维护成本，运维成本（击穿、雪崩、代码复杂度）
3. 缓存更新策略
	1. 内存淘汰：redis自带的内存淘汰机制。一致性差，无维护成本。低一致性需求
	2. 超时剔除：添加TTL时间，一致性一般，维护成本低
	3. 主动更新：编写业务逻辑，一致性好，维护成本高。高一致性需求，以超时剔除作为兜底方案
		1. cache aside pattern：更新数据库的同时更新缓存。
			1. 删除缓存，保证数据库与缓存操作的原子性
				![[Pasted image 20250718140718.png]]
			2. 先删除缓存，再操作数据库
				![[Pasted image 20250718140831.png]]![[Pasted image 20250718140900.png]]
			3. 先操作数据库，再删除缓存
				![[Pasted image 20250718140931.png]]![[Pasted image 20250718141053.png]]
		2. Read/write through pattern：缓存和数据库整合为一个服务，由服务来维护一致性。
		3. write behind caching pattern：增删改查在数据库中做，由其他线程异步将缓存数据持久化到数据库，保证最终一致
4. 常见问题和解决方案
	1. **缓存雪崩**：同一时段大量的缓存key同时失效或者redis服务宕机，导致大量请求到达数据库，带来巨大压力。redis宕机，所有请求直接访问数据库。
	    - 为不同的缓存数据设置不同的*随机*过期时间TTL
	    - 利用redis集群提高服务可用性（哨兵机制）
	    - 给缓存业务添加降级限流策略
	    - 给业务添加多级缓存
	2. **缓存穿透**：客户端请求的数据在redis缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求会打倒数据库
	    - 对空结果也进行缓存（缓存空对象）：额外的内存消耗（解决：设置TTL），短期不一致 
	    - 布隆过滤器：内存占用少。实现复杂，存在误判可能。
		    - 利用布隆过滤算法，在请求进入redis之前先判断是否存在，如果不存在直接拒绝请求
		    - 原理：bat数组，二进制位。将数据基于哈希算法计算出哈希值，转换为二进制位保存到过滤器中0/1
		- 增强id复杂度，避免被猜测
		- 做好数据基础格式校验
		- 加强用户权限校验
		- 做好热点参数的限流
	3. **缓存击穿**：热点key问题，一个被高并发访问并且缓存重建业务较复杂的key突然失效，无数请求访问会在瞬间给数据库带来巨大冲击
	    - 使用互斥锁（Redis 的 SETNX 命令）：没有额外的内存消耗。线程需要等待，性能受影响，可能有死锁风险
		    - ![[Pasted image 20250718154859.png]]
	    - 逻辑过期：无需等待，性能较好，。不保证一致性，实现复杂，有额外内存消耗
		    - ![[Pasted image 20250718155100.png]]
## 优惠券秒杀
### 全局ID生成器
分布式系统下生成全局唯一ID：唯一性，递增性，安全性，高可用，高性能
组成：符号位（1bit），时间戳（31bit），序列号（32bit）
## 分布式锁
## 秒杀优化
## 消息队列
## 达人探店
## 好友关注
## 附近商铺
## 用户签到
## UV统计
## 分布式缓存
## 多级缓存