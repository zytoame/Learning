### scanf注意事项

1. **`scanf_s` 使用**: 在 `scanf_s` 的情况下，使用时的格式与 `scanf` 是相同的，但是在一些情况下，还可能需要提供额外的参数（如读取字符串时的缓冲区大小）。但在这里，我们仅读取一个 `int` 类型的变量，因此直接使用是可以的。
    
2. **输入安全**: 在使用 `scanf_s` 时，你通常需要检查输入的有效性，比如确保输入的数据与格式匹配。
    
3. **编译时警告的处理**: 如果你仍然希望使用 `scanf` 而不想收到警告，可以在源文件的开头添加以下预处理指令来禁用警告：
    
    c
    
    `#define _CRT_SECURE_NO_WARNINGS`
    

在使用 `scanf_s` 的情况下，不再会有不安全函数的警告了，同时程序的功能保持不变。编译和运行此程序的步骤与之前一致。
### 自定义函数
	先声明内部函数ststic short xxxx（）
	计算内部函数的实现ststic short xxxx（）{}
	主函数
### int main(void) VS void main(void)
	system("pause");//void
	return 0;//int
### return 0;
`return` 语句用于从函数中返回控制，并且可以选择性地返回一个值。`main` 函数作为程序的入口点，其返回值（即 `main()` 函数的返回值）通常用于表示程序的退出状态。

- **`return 0;`**：通常表示程序执行成功。操作系统会将返回值 0 解释为“程序正常终止”。
- **`return 1;`**：表示程序执行失败或遇到错误。通常返回值 1 或其他非零值表示程序遇到问题，程序没有正常执行完毕。
- if (count < 1 || count > 366) 
	{
	    printf("输入无效，请输入一个1到366之间的值。\n");
	    return 1;
	}

	-  **输出错误信息**：如果输入无效，程序会打印 `"输入无效，请输入一个1到366之间的值。\n"`，提示用户输入有误。
	 **终止程序**：通过 `return 1;`，程序在此时退出 `main` 函数，并向操作系统返回一个非零值，表示程序由于无效输入而提前终止。此时程序不会继续执行后面的代码。
### c文件API函数实现
1. 错误：
	
	short CalcDay(int tick)
	{
		  ==short day;==
		  short month = CalcMonth(tick);
	  for (int i = 0; i < month; i++) 
	  {
		int days_in_month[] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; 
		==day== = tick - days_in_month[i]; // 循环减去前 month 个月的天数
	  }
	  return(day);
	}
		
2. 正确：
	
	short CalcDay(int tick)
	{
	  ==short day=0;==
	  short month = CalcMonth(tick);
	  for (int i = 0; i < month; i++) 
	  {
	    int days_in_month[] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; 
	    ==tick== -= days_in_month[i]; // 循环减去前 month 个月的天数`
	  }
	  ==day = tick;==
	  return(day);
	}
3. 原因：
	问题出在 for 循环中，day 变量在循环中被赋值，但在循环结束后没有被正确初始化。修复方法是将 tick 减去前 month 个月的天数，并在循环结束后将剩余的 tick 赋值给 day。这样可以确保 day 变量在返回之前被正确初始化。
### printf字符串
	char* 指针类型：
		const char* xxxx;
		xxxx=指针函数（）;
		printf("%s\n",xxxx);
		
		//错误做法：
		short xx;
		xx=指针函数();
		printf("%s\n",xx);


### 打不开/找不到源文件但是文件本身没有问题
	复制后删掉文件再新建

### **“jump to case label [-fpermissive]” 错误**

这个错误表示在 `switch` 语句中的 `case` 标签之间存在跳转，导致编译器认为控制流不符合规定。具体原因是，你的 `switch` 语句中的 `case` 标签使用了局部变量 `days_in_month`，并且在 `case` 标签之间跳转时，会跨越该变量的初始化。

在 `switch` 语句中，`case` 标签之间不能跨越局部变量的初始化。解决这个问题的方法是将局部变量 `days_in_month` 移动到 `switch` 语句外部，避免 `case` 标签之间跨越它的初始化。

###  **“CalcTime.ct;” 声明错误**

你在 `ConvertTime` 类中声明了 `CalcTime.ct;`，这不是有效的对象声明。应该改为一个类成员对象，例如 `CalcTime ct;`，而不是 `CalcTime.ct;`。

### **“ct was not declared in this scope” 错误**

由于你没有正确声明 `ct`，导致编译器找不到该对象，解决方法是确保 `ct` 是 `ConvertTime` 类中的一个有效成员变量。

### error: redefinition of 'int main()'  **重复的 `main` 函数**

### error: 'get_weekday' was not declared in this scope。 **`get_weekday` 声明错误**

### invalid conversion from 'const char*' to 'char' [-fpermissive]
这个错误的原因是 `get_weekday` 函数返回的是 `const char*`（即字符串），而你将其赋值给了一个 `char` 类型的变量 `weekday`。`char` 是一个单字符变量，而 `const char*` 是指向字符数组（即字符串）的指针，因此发生了类型不匹配。
**解决方案：**
你需要将 `weekday` 声明为 `const char*` 类型，而不是 `char` 类型，因为 `get_weekday` 返回的是一个字符串。修改代码如下：

### std::cout << ==u8=="你: ";运行以下代码可以正确输出中文：

原因是 `u8` 前缀将字符串字面量显式地标记为 **UTF-8 编码** 的字符串。UTF-8 是一种广泛使用的 Unicode 编码方式，能够表示几乎所有的字符，包括中文字符。以下是对这一现象的详细解释：

---
#### 1. `u8` 前缀的作用
`u8` 是 C++11 引入的字符串字面量前缀，用于表示 **UTF-8 编码的字符串**。当你使用 `u8"你: "` 时，编译器会将字符串编码为 UTF-8 格式。

UTF-8 是一种变长编码，中文字符通常占用 3 个字节。例如，`"你"` 的 UTF-8 编码是 `0xE4 0xBD 0xA0`。

---
#### 2. 控制台编码匹配
`std::cout` 默认会将字符串按字节输出到控制台。如果控制台的编码与字符串的编码一致（例如都是 UTF-8），那么中文字符就能正确显示。

在你的情况下，可能是因为以下原因之一：
- 控制台已经设置为 UTF-8 编码（例如通过 `chcp 65001` 命令）。
- Visual Studio 2022 的调试控制台默认支持 UTF-8 输出。
- 系统区域设置或环境配置支持 UTF-8。

---

#### 3. 源代码文件的编码
为了确保 `u8"你: "` 能够正确编译，你的源代码文件必须保存为 **UTF-8 编码**。如果源代码文件是其他编码（如 GB2312 或 ANSI），编译器可能会错误地解释字符串字面量，导致乱码。

在 Visual Studio 2022 中，你可以通过以下步骤确保文件保存为 UTF-8：
1. 打开源代码文件。
2. 点击菜单栏的 **文件 > 另存为**。
3. 在保存对话框中，点击 **保存** 按钮旁边的下拉箭头，选择 **编码保存**。
4. 选择 **UTF-8 带签名（带 BOM）**，然后保存文件。

---

#### 4. 为什么 `std::cout` 可以输出 UTF-8 字符串？
`std::cout` 是一个字节流输出工具，它会将字符串按字节输出到控制台。如果字符串是 UTF-8 编码的，而控制台也支持 UTF-8 编码，那么中文字符就能正确显示。

例如：
- `u8"你: "` 的 UTF-8 编码是 `0xE4 0xBD 0xA0 0x3A 0x20`。
- `std::cout` 会将这些字节原样输出到控制台。
- 如果控制台能够正确解析 UTF-8 编码，就会显示 `你: `。
---
#### 5. 对比其他字符串前缀
- **无前缀**：`"你: "`  
  字符串的编码取决于源代码文件的编码。如果文件是 UTF-8 编码，则字符串是 UTF-8；如果文件是 GB2312 编码，则字符串是 GB2312。如果控制台编码不匹配，可能会导致乱码。

- **`u8` 前缀**：`u8"你: "`  
  强制将字符串编码为 UTF-8，确保编码一致性。

- **`L` 前缀**：`L"你: "`  
  将字符串编码为宽字符（`wchar_t`），通常用于 UTF-16 或 UTF-32 编码。需要使用 `std::wcout` 输出。

- **`u` 前缀**：`u"你: "`  
  将字符串编码为 UTF-16。

- **`U` 前缀**：`U"你: "`  
  将字符串编码为 UTF-32。
---
#### 6. 总结
`std::cout << u8"你: ";` 能够正确输出中文的原因是：
1. **`u8` 前缀确保字符串是 UTF-8 编码。**
2. 控制台支持 UTF-8 编码（或者系统环境配置正确）。
3. 源代码文件保存为 UTF-8 编码。

如果你在其他环境中遇到乱码问题，可以尝试以下方法：
- 使用 `SetConsoleOutputCP(CP_UTF8)` 设置控制台编码为 UTF-8。
- 确保源代码文件保存为 UTF-8 编码。
- 使用宽字符输出（`std::wcout` 和 `L"你: "`）。
---
#### ==你遇到的问题是一个非常典型的编码问题，根本原因是 **源代码文件的编码** 和 **字符串字面量的编码** 不一致。以下是对问题的详细分析和解决方法：==

---
#### 1. 问题的根本原因
##### 情况 1：未使用 `u8` 前缀
```cpp
std::cout << "你好，世界！" << std::endl;
```
- 这里的字符串字面量 `"你好，世界！"` 的编码取决于 **源代码文件的编码**。
- 如果源代码文件保存为 **UTF-8 带 BOM** 或 **UTF-8 无 BOM**，编译器会将其解释为 UTF-8 编码。
- 如果源代码文件保存为其他编码（如 GB2312 或 ANSI），编译器会将其解释为对应的编码。
- 如果控制台的输出编码设置为 UTF-8（通过 `SetConsoleOutputCP(CP_UTF8);`），但字符串的实际编码不是 UTF-8，就会导致乱码。
##### 情况 2：使用 `u8` 前缀
```cpp
std::cout << u8"你好，世界！" << std::endl;
```
- **这里的 `u8` 前缀强制将字符串字面量编码为 **UTF-8**，无论源代码文件的编码是什么。**
- 因此，即使源代码文件保存为其他编码（如 GB2312），`u8"你好，世界！"` 也会被编译器正确编码为 UTF-8。
- 由于控制台的输出编码设置为 UTF-8，字符串能够正确显示。

---
#### 2. 为什么未加 `u8` 时会出现乱码？
在你的情况下，未加 `u8` 时出现乱码，可能是因为：
1. **源代码文件的编码不是 UTF-8**：
   - 如果源代码文件保存为 GB2312 或 ANSI 编码，字符串 `"你好，世界！"` 会被编译器解释为 GB2312 或 ANSI 编码。
   - 当控制台尝试以 UTF-8 编码解析这些字节时，由于编码不匹配，就会显示乱码。

2. **编译器未正确处理源代码文件的编码**：
   - 即使源代码文件保存为 UTF-8，如果**编译器没有正确识别文件的编码**，字符串仍然可能被错误地解释为其他编码。

---
#### 3. 为什么加上 `u8` 后能正确输出？
加上 `u8` 后能正确输出，是因为：
1. **`u8` 前缀强制将字符串编码为 UTF-8**：
   - 无论源代码文件的编码是什么，`u8"你好，世界！"` 都会被编译器编码为 UTF-8。
   - 这样，字符串的编码与控制台的输出编码（UTF-8）一致，因此能够正确显示。

2. **UTF-8 编码的普适性**：
   - UTF-8 是一种通用的 Unicode 编码方式，能够表示几乎所有的字符，包括中文字符。

---
#### 4. 解决方法
要解决未加 `u8` 时的乱码问题，可以采取以下方法：
##### ~~方法 1：确保源代码文件保存为 UTF-8 编码
1. 打开源代码文件。
2. 点击菜单栏的 **文件 > 另存为**。
3. 在保存对话框中，点击 **保存** 按钮旁边的下拉箭头，选择 **编码保存**。
4. 选择 **UTF-8 带签名（带 BOM）**，然后保存文件。
5. 重新编译并运行程序。
##### 方法 2：==在代码中显式使用 `u8` 前缀==
如果你不想修改源代码文件的编码，可以在所有需要输出中文字符的地方使用 `u8` 前缀：
```cpp
std::cout << u8"你好，世界！" << std::endl;
```
##### 方法 3：设置编译器选项
在 Visual Studio 中，可以通过设置编译器选项强制将源代码文件解释为 UTF-8：
1. 打开项目属性（右键点击项目名称，选择 **属性**）。
2. 在 **配置属性 > C/C++ > 命令行** 中，添加以下选项：
   ```
   /utf-8
   ```
3. 点击 **确定** 保存设置。
#####  ~~方法 4：检查控制台字体~~
~~确保控制台的字体支持 Unicode 字符：
1. ~~打开命令提示符（cmd）。
2. ~~右键点击标题栏，选择 **属性**。
3. ~~在 **字体** 选项卡中，选择支持中文的字体（如 **Consolas** 或 **Lucida Console**）。
4. ~~点击 **确定** 保存设置。~~

---
#### 5. 总结
- **未加 `u8` 时出现乱码，是因为源代码文件的编码与控制台的输出编码不匹配。**
- 加上 `u8` 后能正确输出，是因为 `u8` 前缀强制将字符串编码为 UTF-8，确保编码一致性。
- 解决方法包括：
  1. 确保源代码文件保存为 UTF-8 编码。
  2. 显式使用 `u8` 前缀。
  3. 设置编译器选项 `/utf-8`。
  4. 检查控制台字体是否支持 Unicode 字符。
